package com.eme.ims.client;import java.net.InetSocketAddress;import java.net.SocketAddress;import org.apache.mina.core.future.ConnectFuture;import org.apache.mina.core.service.IoHandlerAdapter;import org.apache.mina.core.session.IoSession;import org.apache.mina.filter.codec.ProtocolCodecFactory;import org.apache.mina.filter.codec.ProtocolCodecFilter;import org.apache.mina.filter.executor.ExecutorFilter;import org.apache.mina.filter.logging.LoggingFilter;import org.apache.mina.transport.socket.SocketSessionConfig;import org.apache.mina.transport.socket.nio.NioSocketConnector;import android.util.Log;import com.eme.ims.codec.MessageCodecFactory;import com.eme.ims.utils.PropertyConfig;public class MessageClient {		private static final String LOG_TAG = "MessageClient";	private NioSocketConnector connector;	private IoHandlerAdapter handler = null;	private IoSession session = null;		private String host;	private int port;		private PropertyConfig config;		public MessageClient(PropertyConfig config, IoHandlerAdapter handler) {		this.config = config;		this.host = config.getString("server.host");		this.port = config.getInteger("server.port");		this.handler = handler;	}		public boolean connect() {				boolean result = false;				ProtocolCodecFactory codecFactory = new MessageCodecFactory(config);				connector = new NioSocketConnector();		connector.setHandler(handler);		connector.getFilterChain().addLast("logger", new LoggingFilter());		connector.getFilterChain().addLast("codec", new ProtocolCodecFilter(codecFactory));		connector.getFilterChain().addLast("threadPool", new ExecutorFilter());		connector.getSessionConfig().setTcpNoDelay(true);				SocketSessionConfig socketSessionCfg = connector.getSessionConfig();		socketSessionCfg.setKeepAlive(true);		socketSessionCfg.setWriteTimeout(30);		socketSessionCfg.setBothIdleTime(60);				try {			SocketAddress address = new InetSocketAddress(host, port);			ConnectFuture future = connector.connect(address);			future.awaitUninterruptibly(10000);			if (!future.isConnected())			{				Log.e(LOG_TAG, "failed to connect to ["+host+":"+port+"]!");				return false;			}			session = future.getSession();			result = true;			Log.d(LOG_TAG, "connect to server successfully!");		} catch (Exception e) {			Log.d(LOG_TAG, "Exception encountered while connect to server.");			result = false;		}				return result;	}		public boolean sendMessage(Object message) {				boolean result = false;				if (this.sessionIsAvailable()) {			try {				session.write(message);				result = true;			} catch (Exception e) {				Log.w(LOG_TAG, "failed to send messsage: ["+message.toString()+"]");			}		}				return result;	}		public boolean disconnect() {				boolean result = false;		if (null != connector && connector.isActive()) {			connector.dispose();			result = true;		} 		Log.d(LOG_TAG, "disconnected.");		return result;			}			public boolean sessionIsAvailable()  {				boolean result = false;				if (null != session && session.isConnected() && !session.isBothIdle()) {			Log.d(LOG_TAG, "session is available");			result = true;		} else {			Log.w(LOG_TAG, "session is not available.");		}				return result;	}	}